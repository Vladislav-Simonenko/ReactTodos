
import React, { useEffect, useState } from "react";
import PostService from "../API/PostService";
import PostFilter from "../components/PostFilter";
import PostForm from "../components/PostForm";
import Postlist from "../components/Postlist";
import { useFetching } from "../hooks/useFetching";
import { usePosts } from "../hooks/usePost";
import "../styles/App.css"
import MyButton from "../UI/button/MyButton";
import Loader from "../UI/Loader/Loader";
import MyModal from "../UI/MyModal/MyModal";
import Pagination from "../UI/paginations/Pagination";
import { getPageArray, getPagesCount } from "../utils/pages";



function Posts() {
  //создадим состояние с массивом постов.
  const [posts, setPosts] = useState([])




  //получение данных из НЕ  УПРАВЛЯЕМОГО элемента используем useRef, этим хуком, мы получим доступ к дом элементу и у этого элемента, забрать велью.
  //у инпута указываем пропс ref и передаем туда ссылку, у этой ссылки одно поле current это и есть dom элемент. у него есть поле value, которое мы можем получить.bodyInputRef.current.value
  // создав обычный инвут и передав туда ref, мы получили доступ к обычному дом элементу. не рекомендуется в рект, но бывает необходимо
  // const bodyInputRef = useRef() - для неуправляемых компонентов
//функция на вход ожидает новый созданный пост, его мы передаем в аргументе, и все что мы делаем, это изменяем состояние
//разворачиваем туда старый массив и в конец передаем новый, теперь эту функцию вызываем внутри postForm, мы знаем что пропс называется create -> 

//реализуем двухсторонне связывание с выпадающим списком

//const [selectedSort, setSelectedSort] = useState("")
// const [searchQuery, setSearchQuery] = useState("") -удаляем эти два состояния и создадим новое, одно состояние
const [filter, setFilter] = useState({sort:"", query:"",})

//сделаем состояние, которое отвечает, видимо модальное окно или нет и что бы мы могли этим динамически управлять
const [modal, setModal] = useState(false)

// Вызываем созданный касомно хук
const sortedAndResearchedPosts = usePosts(posts, filter.sort, filter.query)

//создадим состояние, в котором будем хранить общее колличество постов
//переименуем состояние с totalCount, setTotalCount в ->
const [totalPage, setTotalPage] = useState(0);
//по умолчанию 0, так как не знаем сколько страниц на сервере, затем обращаемся к хэдэрам и достаем тот самый хэдэр

const [limit, setLimit] = useState(10);

//также создадим состояние где будем хранить номер текущей страницы.
const [page, setPage] = useState(1);

  //создадим крутилку для сервера.
  //const[isPostsLoading, setIsPostsLoading] = useState(false); удалим это состояние и заменим кастомным хуком.

  //также подправляем немного тут, передаем не посты, а поле data у response
  const [fetchPosts, isPostsLoading, postError] = useFetching(async () =>{
    //передаем лимит и номер страницы через отдельное состояние 
    const response = await PostService.getAll(limit, page);
    setPosts(response.data)
    //подставим функцию и посчитаем общее кол-во страниц.
    //достаем из зэдера общее число постов и передаем эти данные в функцию
    const totalCount = (response.headers['x-total-count']);
    //вызываем эту функцию и первым параметром передаем 
    setTotalPage(getPagesCount(totalCount, limit))
    //, затем обращаемся к хэдэрам и достаем тот самый хэдэр
  }); 


  //зная общее колличество страниц, можем сформировать массив, в в котором значения идут от 1 до 10, и на основании массива, нарисовать кнопки, при нажатии на которые, меняется страницы.
  //сделаем простой вариант, будем заполнять массив в цике
  //вызываем тут эту функцию и передаем туда состояние totalpage
  


  // сделаем декомпозицию и вынесем функционал по заполнению массива в отдельную функцию


  //воспользуемся хуком useEffect
  //массив зависимостей сделаем пустым, что бы функция отработала 1 раз

  //что бы убрать отставание, добавим в useEffect номер страницы, а вызов функции уберем вообще

  useEffect(() =>{
    fetchPosts()
  }, [page])

  const createPost = (newPost) => {
    setPosts([...posts, newPost])
    setModal(false)
  }

  // используем сервер JSON placeholder и установим библиотеку axios
  // реализуем функциЮ, которая будет отправлять запрос на сервер, получать данные и помещать в состояние с постами
  //вместо огромного запроса, обратимся к функции 
  //также меняем названия переменных
    //перед отправкой запроса делаем состояние true setIsPostsLoading

    //создадим кастомный хук useFetching




  //недостаточно просто засунуть опцию в состояние, после того как пользователь выбрал опцию, необходимо массив отсортировать, создадим функцию 
  //вызываем функцию setPosts, чтобы передать туда отсортированный массив. функция sort не возвращаем новый массив, а мутирует старый
  //поэтому мы развернем посты в новый массив,и отсортируем его. вызываем функцию sort, эта функция принимает callback, который аргументами принимает 2 элемента массива.
  //мы берем поле которое выбрал пользователь и для сравнения строк используем localeCompare


    //сортировку реализовали, теперь реализуем механизм поиска. над селектом создадим инпут и сделаем его управляемым
  //для поиска необходимо реализовать фильтрацию и удалять ненужные элементы из массива, перенесем механизм сортировки 
  //и передаем в postlist уже отсортированный массив постов

  //так как селектедсорт пустая строка, то конструкция не отработает и выдаст ошибку, так как мы пытаемся получит несуществующее поле и вызываем у него localeCompare, у него этого поля нет,
  //получим undefined и пытаемсчя у него вызвать фунцию.
  //создадим функцию и проверяем, если selectedSort существует, то возвращаем отсортированный массив, в обратном случае обычной массив постов.
  // так как функция вызывается при любом изменении инпута, то это ударит по производительности. Знакомимся с хуком useMemo

  //useMemo(callback, deps) первым параметром принимает callback, функцию обратного вызова, вторым массив зависимостей.
  //useMemo(()=>{return [...posts.sort(...)]},[selectedSort, posts]) callback должен возвращать результат вычислений(отсортированный массив, мат операции и тп)
  //в массив зависемостей можно передавать переменные, поля объекта. Этот хук нужен для производства вычеслений, запоминает их, и кеширует, это называется мемоизация
  //каждую перерисовку она не пересчитывает заного, она достает массив из кеша, когда мы выбираем другой результат сортировки, 
  //функция пересчитывает его и кеширует до тех пор, пока из зависимостей не изменится, если массив зависимостей пустой, функция отработает 1 раз и вызыватся больше не будет.

  //воспользуемся этим хуком
 

  //делаем поиск на основании отсортированного массива. в массив попадает отсортированная строка и сам массив.


  //ХУК useEffect - можно использовать столько раз, сколько необходимо. похож на useMemo, принимает callback и массив зависимостей
  //когда массив зависимостей пустой, callback отработает только 1 раз в момент монтирования, таким образом можно отследить стадию монтирования и выполнить действия.
  // чтобы следить за изменениями, необходимо добавить зависимости в массив. и хук отработает на каждое изменение в массиве зависимостей
  //можно следить за стадией размонтирования. если callback возвращает функцию, то эта функция будет вызвана в момент демонтирования компонента. в этот момент чистится хранилище, делается очистка


    //реализуем функцию удаления, принцип будет такойже, с функцией обратного вызова, так как в дочернем компоненте, нет доступа к состоянию родителя.
//аргументом принимаем post из дочернего компонента. и из массива постов необходимо удалить тот пост, который мы передали аргументом. 
//для этого предназначена функция filter, которая вернет новый массив, отфильтрованный по условию.
// в функции просто проверяем id. если он равен тому id, который мы передали постом, то тогда удаляем элемент из массива.
const removePost = (post) =>{
  setPosts(posts.filter(p => p.id !== post.id))
}

//создадим функцию, которая будет изменять номер страницы и подгружать данные.
//передадим функцию на кнопку и будем вызывать fetchPosts 



//при таком подходе есть небольшое отстование
const changePage = (page) =>{
  setPage(page)
}
  return (
    // добавим кнопку, которая для вызова функции, которую мы сделали(для отправки асинхзронного запроса на сервер)


    //что бы добавить класс на элемент, необходимо использовать слово className 
    //в компонент postitem передаем значения пропсов.

    //использовать можно столько списков, сколько нам нуобходимо, используя для разных списков разные входные данные.
    <div className="App">
          <button onClick={fetchPosts}> GET POST </button>
      {/*Управляемый компонент*/}
      {/*Передаем в компонент функцию обратного вызова, сам пропс называем create, а функция createPost и создадим ее выше.*/}
      <MyButton onClick={() => setModal(true)}>
        Создать пользователя
      </MyButton>
      <MyModal 
      visible={modal}
      setVisible = {setModal}
      > 
      <PostForm create={createPost}/>
      </MyModal>

      {/*Создадим сортировку*/}     
      <hr style={{margin: "15px 0", border: "1px solid black"}}/>
      <PostFilter 
      filter = {filter}
      setFilter = {setFilter}
      />
       {/*Дабивим условную отрисовку при удалении всех постов, добавим условие, если длинна массива не равна нулю, то отрисовываем посты, если их нет, создаем какой то элемент 
       и пишем что постов нет. запись можно упростить, убрав !== 0 и поведение не изменится*/}
      {/* ставим условие над списком постов.*/}
      {postError && 
      <h1>Ошибка ${postError}</h1>
      }
      {isPostsLoading
      ?
      <div style={{display: "flex", justifyContent: "center", marginTop: "50px"}}> <Loader/> </div>
      : 
      <Postlist remove={removePost} posts={sortedAndResearchedPosts} title="Список постов про JS" />
      }
      
      
{/*в postlist мы передавали отсортированный массив, теперь передаем отсортированный и отфильтрованный массив*/}  
{/*Сделаем компонент чище, удалим условие и перенесем в сам компонент*/}  
{/*рисуем на основании массива кнопки с номерами страниц, итерируемся по массиву через map и создаем кнопку для каждой страницы, сделаем стили отличные от общих. перенесем в отдельный компонент*/}  
{/* добавим компонент paginations  и передадим сразу просы*/}
<Pagination page={page} changePage={changePage} totalPage={totalPage}/>
    </div>
  );
}

export default Posts;

