import React, { useState } from 'react';
import MyButton from '../UI/button/MyButton';
import MyInput from '../UI/input/MyInput';

// -> и так как это функция, мы ее можем вызвать,
const PostForm = ({create}) => {
      //получить данные из управляемого инпута

  // чтобы не создавать для каждого инпута отдельное состояние, в качестве значения можно использовать объект, и для каждого инпута, использовать поле этого объекта.
  //создадим вместо   const [title, setTitle] = useState(""),   const [body, setBody] = useState(""), состояние ->
  //инициализируем эти поля сразу пустыми строками
  //также меняем функцию onChange. передаем туда объект в который разворачиваем старый пост(все поля, и перезатираем конкретное поле в этом инпуте.)
  const [post, setPost] = useState({
    title: "",
    body: "",

  })

  const addNewPost = (e) => {

    e.preventDefault()


    //так как вся нужная информация уже находится в объекте, то создавать новую переменную не обязательно, можно создать новый объект прямо в массиве,развернуть туда инфу из поста и добавить ID

    //созданный объект добавляем в массив постов, вызываем функцию setPost, передаем туда новый массив, где разворачиваем старый массив с постами и в конец добавляем новый пост.
    //запомнить, так это важная концепция.

    // setPosts([...posts, {...post, id: Date.now()}]) - так как у нас нет доступа к этому компоненту, мы его удаляем, и создадим новый объект.
    //в него развернем список постов и присвоим id
    const newPost = {
        ...post, id: Date.now()
    }
// делаем деструктуризацию пропсов, вызываем функцию create и передаем туда новый пост
create(newPost)
//теперь необходимо этот поста добавить в массив

     //что бы очищались поля, вызываем функции тайтла и бади с пустыми строками.
     //после изменений, для обнуления формы, достаточно вызвать функцию сетПост
    setPost( {title: "", body: ""})
  }


    return (
        <form>
        <MyInput
          value={post.title}
          onChange={e => setPost({...post, title: e.target.value})}
          type="text"
          placeholder="Название поста"
        />  
          {/*НЕ Управляемый компонент, неконтролируемый, использовался useRef*/}
        <MyInput
        value={post.body}
        onChange={e => setPost({...post, body: e.target.value})}
        type="text"
        placeholder="Описание поста"
        />
        <MyButton onClick={addNewPost}>Создать пост</MyButton>
      </form>
    );
};

export default PostForm;


//пропсы - это аргумента(параметры), которые может принимать компонент из вне. но обмен пропсами идет сверху вниз, от родителя в дочерний компонент.
//мы из App передавали список постов в postlist, но теперь есть компонент postform, который должен создать новый пост и отдать его наверх, что бы мы могли добавить пост в массив.
//РЕШЕНИЕ: передать callback из ребенка в родителя.(функцию обратного вызова.) эта функция будет ожидать пост и внутри себя, полученные через аргументы пост будет добавлять в массив
//вызываем эту функцию в дочернем компоненте и созданные пост попадает в нужный массив. таким образом мы передаем данные снизу вверх.
